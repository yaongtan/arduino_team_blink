int led_pins[] = { 8, 9, 10, 11 };
int button_pins[] = { 14, 15, 16, 17 };
int ifbuttons[] = { 0, 0, 0, 0 };

//LED 순서와 버튼 클릭 순서 기록을 위한 변수
int sequence[1024];
int my_button_click[1024];
int sequence_num = 8;

//delay를 사용할 시, 센서 감지, 연산 등에서 오류 발생 가능성이 많기에
//TIMER 구조체를 따로 생성하여 사용함
struct Timer {
  unsigned long previous = 0;
  unsigned long interval;

  Timer(unsigned long p = 0, unsigned long i = 1000) {
    previous = p;
    interval = i;
  }
};

//interval에 해당하는 초 마다 true를 반환하는 함수(struct(구조체)를 이용하여 각각의 previous를 독립적으로 연산함)
bool per_time_interval(Timer &t) {
  int time_current = millis();
  if (time_current - t.previous >= t.interval) {
    t.previous = time_current;
    return true;
  }
  return false;
}

//LED 순서 랜덤 생성(num에 해당하는 만큼 순서를 생성함)
void make_random_sequence(int num) {
  for (int i = 0; i < num; i++) {
    sequence[i] = random(1, 5);
  }
}

//버튼 클릭 감지(i에 해당하는 인덱스의 버튼을 감지함)
bool button_ifclicked(int i) {
  if (digitalRead(button_pins[i])) {
    if (!ifbuttons[i]++)
      return true;
    delay(50);
  } else ifbuttons[i] = 0;
  return false;
}

//sequence의 값을 하나씩 반환함
int* psequence = sequence;
int led_pins_from_sequence() {
  if (*psequence)
    return led_pins[*psequence++ - 1];
  return 0;
}

//led 온오프 관리 함수
void led_onoff(int pin) {
  for (int i = 8; i <= 11; i++)
    digitalWrite(i, i == pin);
}

//셋업(LED 출력 시퀀스를 임시로 출력하게 해놓았기에 확인 가능(추후 삭제 예정))
void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0));
  make_random_sequence(sequence_num);

  Serial.println();
  for (int i = 0; i < sequence_num; i++)
    Serial.print(sequence[i]);
  Serial.println();
  
  for (int i = 0; i < 4; i++) {
    pinMode(led_pins[i], OUTPUT);
    pinMode(button_pins[i], INPUT);
  }

  delay(1000); //시작 전 딜레이 추후 삭제 예정 
}

//TIMER 생성(LED 출력 주기와 켜진 이후 꺼질 때까지의 딜레이 2개)
// 추후 가장 적합한 딜레이로 수정 예정
Timer led_timer1(0, 800);
Timer led_timer2(0, 500);

// 메인 루프
int onoff = 0;
void loop() {
  if (per_time_interval(led_timer1)) {
    led_onoff(led_pins_from_sequence());
    onoff = 1;
    led_timer2.previous = millis();
  }
  if (onoff)
    if (per_time_interval(led_timer2)) {
      led_onoff(0);
      onoff = 0;
    }
}
